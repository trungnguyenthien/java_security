<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/tx/secure/RandomHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/tx/secure/RandomHelper.java" />
              <option name="originalContent" value="package tx.secure;&#10;&#10;public interface RandomHelper {&#10;    byte[] nextBytes(int length);&#10;&#10;    int nextInt(int bound);&#10;&#10;    long nextLong(long bound);&#10;&#10;    long nextLong(long origin, long bound);&#10;&#10;    int nextInt(int origin, int bound);&#10;&#10;    double nextDouble();&#10;&#10;    double nextDouble(double origin, double bound);&#10;}&#10;" />
              <option name="updatedContent" value="package tx.secure;&#10;&#10;public interface RandomHelper {&#10;    byte[] nextBytes(int length);&#10;    int nextInt(int bound);&#10;    int nextInt(int origin, int bound);&#10;    long nextLong(long bound);&#10;    long nextLong(long origin, long bound);&#10;    double nextDouble();&#10;    double nextDouble(double origin, double bound);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/tx/secure/RandomHelperImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/tx/secure/RandomHelperImpl.java" />
              <option name="originalContent" value="package tx.secure;&#10;&#10;import java.security.SecureRandom;&#10;&#10;/**&#10; * RandomHelper provides a set of utility methods for generating&#10; * cryptographically secure random values using {@link SecureRandom}.&#10; *&#10; * &lt;p&gt;This class is designed to be simple, safe, and easy to maintain.&#10; * It reuses a single {@code SecureRandom} instance across the application.&lt;/p&gt;&#10; *&#10; * &lt;h2&gt;Sample usage:&lt;/h2&gt;&#10; * &lt;pre&gt;{@code&#10; * // Generate 32 random bytes (e.g., for a cryptographic key)&#10; * byte[] key = RandomHelper.nextBytes(32);&#10; *&#10; * // Generate a random integer between 0 (inclusive) and 100 (exclusive)&#10; * int randInt = RandomHelper.nextInt(100);&#10; *&#10; * // Generate a random integer between 50 (inclusive) and 200 (exclusive)&#10; * int randIntInRange = RandomHelper.nextInt(50, 200);&#10; *&#10; * // Generate a random long between 0 (inclusive) and 1_000_000 (exclusive)&#10; * long randLong = RandomHelper.nextLong(1_000_000L);&#10; *&#10; * // Generate a random long between 10 (inclusive) and 1000 (exclusive)&#10; * long randLongInRange = RandomHelper.nextLong(10, 1000);&#10; *&#10; * // Generate a random double between 0.0 and 1.0&#10; * double randDouble = RandomHelper.nextDouble();&#10; *&#10; * // Generate a random double between 5.5 (inclusive) and 10.0 (exclusive)&#10; * double randDoubleInRange = RandomHelper.nextDouble(5.5, 10.0);&#10; * }&lt;/pre&gt;&#10; */&#10;public class RandomHelperImpl implements RandomHelper {&#10;    /** Singleton instance of SecureRandom, seeded automatically by the OS */&#10;    private final SecureRandom secureRandom = new SecureRandom();&#10;&#10;    /**&#10;     * Generates a random byte array of the given length.&#10;     *&#10;     * @param length the number of bytes to generate&#10;     * @return a byte array filled with random values&#10;     */&#10;    @Override&#10;    public byte[] nextBytes(int length) {&#10;        byte[] bytes = new byte[length];&#10;        secureRandom.nextBytes(bytes);&#10;        return bytes;&#10;    }&#10;&#10;    /**&#10;     * Generates a random integer between 0 (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param bound the upper bound (exclusive). Must be positive.&#10;     * @return a random integer between 0 and bound - 1&#10;     */&#10;    @Override&#10;    public int nextInt(int bound) {&#10;        return secureRandom.nextInt(bound);&#10;    }&#10;&#10;    /**&#10;     * Generates a random long between 0 (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param bound the upper bound (exclusive). Must be positive.&#10;     * @return a random long between 0 and bound - 1&#10;     */&#10;    @Override&#10;    public long nextLong(long bound) {&#10;        return secureRandom.nextLong(bound);&#10;    }&#10;&#10;    /**&#10;     * Generates a random long between {@code origin} (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param origin the lower bound (inclusive)&#10;     * @param bound the upper bound (exclusive). Must be greater than origin.&#10;     * @return a random long between origin and bound - 1&#10;     */&#10;    @Override&#10;    public long nextLong(long origin, long bound) {&#10;        return secureRandom.nextLong(origin, bound);&#10;    }&#10;&#10;    /**&#10;     * Generates a random integer between {@code origin} (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param origin the lower bound (inclusive)&#10;     * @param bound the upper bound (exclusive). Must be greater than origin.&#10;     * @return a random integer between origin and bound - 1&#10;     */&#10;    @Override&#10;    public int nextInt(int origin, int bound) {&#10;        return secureRandom.nextInt(origin, bound);&#10;    }&#10;&#10;    /**&#10;     * Generates a random double between 0.0 (inclusive) and 1.0 (exclusive).&#10;     *&#10;     * @return a random double between 0.0 and 1.0&#10;     */&#10;    @Override&#10;    public double nextDouble() {&#10;        return secureRandom.nextDouble();&#10;    }&#10;&#10;    /**&#10;     * Generates a random double between {@code origin} (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param origin the lower bound (inclusive)&#10;     * @param bound the upper bound (exclusive). Must be greater than origin.&#10;     * @return a random double between origin and bound&#10;     */&#10;    @Override&#10;    public double nextDouble(double origin, double bound) {&#10;        return secureRandom.nextDouble(origin, bound);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tx.secure;&#10;&#10;import java.security.SecureRandom;&#10;&#10;/**&#10; * RandomHelper provides a set of utility methods for generating&#10; * cryptographically secure random values using {@link SecureRandom}.&#10; *&#10; * &lt;p&gt;This class is designed to be simple, safe, and easy to maintain.&#10; * It reuses a single {@code SecureRandom} instance across the application.&lt;/p&gt;&#10; *&#10; * &lt;h2&gt;Sample usage:&lt;/h2&gt;&#10; * &lt;pre&gt;{@code&#10; * // Generate 32 random bytes (e.g., for a cryptographic key)&#10; * byte[] key = RandomHelper.nextBytes(32);&#10; *&#10; * // Generate a random integer between 0 (inclusive) and 100 (exclusive)&#10; * int randInt = RandomHelper.nextInt(100);&#10; *&#10; * // Generate a random integer between 50 (inclusive) and 200 (exclusive)&#10; * int randIntInRange = RandomHelper.nextInt(50, 200);&#10; *&#10; * // Generate a random long between 0 (inclusive) and 1_000_000 (exclusive)&#10; * long randLong = RandomHelper.nextLong(1_000_000L);&#10; *&#10; * // Generate a random long between 10 (inclusive) and 1000 (exclusive)&#10; * long randLongInRange = RandomHelper.nextLong(10, 1000);&#10; *&#10; * // Generate a random double between 0.0 and 1.0&#10; * double randDouble = RandomHelper.nextDouble();&#10; *&#10; * // Generate a random double between 5.5 (inclusive) and 10.0 (exclusive)&#10; * double randDoubleInRange = RandomHelper.nextDouble(5.5, 10.0);&#10; * }&lt;/pre&gt;&#10; */&#10;public class RandomHelperImpl implements RandomHelper {&#10;    /** Singleton instance of SecureRandom, seeded automatically by the OS */&#10;    private final SecureRandom secureRandom;&#10;&#10;    /** Creates a new instance of {@code RandomHelperImpl} with a secure random number generator. */&#10;    public RandomHelperImpl() {&#10;        this.secureRandom = new SecureRandom();&#10;    }&#10;&#10;    /**&#10;     * Generates a random byte array of the given length.&#10;     *&#10;     * @param length the number of bytes to generate&#10;     * @return a byte array filled with random values&#10;     */&#10;    @Override&#10;    public byte[] nextBytes(int length) {&#10;        byte[] bytes = new byte[length];&#10;        secureRandom.nextBytes(bytes);&#10;        return bytes;&#10;    }&#10;&#10;    /**&#10;     * Generates a random integer between 0 (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param bound the upper bound (exclusive). Must be positive.&#10;     * @return a random integer between 0 and bound - 1&#10;     */&#10;    @Override&#10;    public int nextInt(int bound) {&#10;        return secureRandom.nextInt(bound);&#10;    }&#10;&#10;    /**&#10;     * Generates a random integer between {@code origin} (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param origin the lower bound (inclusive)&#10;     * @param bound the upper bound (exclusive). Must be greater than origin.&#10;     * @return a random integer between origin and bound - 1&#10;     */&#10;    @Override&#10;    public int nextInt(int origin, int bound) {&#10;        return secureRandom.nextInt(origin, bound);&#10;    }&#10;&#10;    /**&#10;     * Generates a random long between 0 (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param bound the upper bound (exclusive). Must be positive.&#10;     * @return a random long between 0 and bound - 1&#10;     */&#10;    @Override&#10;    public long nextLong(long bound) {&#10;        return secureRandom.nextLong(bound);&#10;    }&#10;&#10;    /**&#10;     * Generates a random long between {@code origin} (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param origin the lower bound (inclusive)&#10;     * @param bound the upper bound (exclusive). Must be greater than origin.&#10;     * @return a random long between origin and bound - 1&#10;     */&#10;    @Override&#10;    public long nextLong(long origin, long bound) {&#10;        return secureRandom.nextLong(origin, bound);&#10;    }&#10;&#10;    /**&#10;     * Generates a random double between 0.0 (inclusive) and 1.0 (exclusive).&#10;     *&#10;     * @return a random double between 0.0 and 1.0&#10;     */&#10;    @Override&#10;    public double nextDouble() {&#10;        return secureRandom.nextDouble();&#10;    }&#10;&#10;    /**&#10;     * Generates a random double between {@code origin} (inclusive) and {@code bound} (exclusive).&#10;     *&#10;     * @param origin the lower bound (inclusive)&#10;     * @param bound the upper bound (exclusive). Must be greater than origin.&#10;     * @return a random double between origin and bound&#10;     */&#10;    @Override&#10;    public double nextDouble(double origin, double bound) {&#10;        return secureRandom.nextDouble(origin, bound);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>